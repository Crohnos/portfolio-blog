<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Tools I Use for Web Dev And Why</title>
  <meta name="description" content="A personal portfolio and blog site">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <link rel="stylesheet" href="/portfolio-blog/css/style.css">
</head>
<body>
  <div class="container">
    <header>
      <h1><a href="/portfolio-blog/" id="site-title">Portfolio Blog</a></h1>
      <nav>
        <ul>
          <li><a href="/portfolio-blog/">Home</a></li>
        </ul>
      </nav>
    </header>
    
    <main id="app">
      
      <article class="blog-post">
        <header class="post-header">
          <div class="post-categories">
            <span class="category-badge">Web Development</span><span class="category-badge">Tools</span><span class="category-badge">JavaScript</span>
          </div>
          <h1 class="post-title">The Tools I Use for Web Dev And Why</h1>
          <div class="post-meta">
            <div class="post-author">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
              </svg>
              <span>John Graham</span>
            </div>
            <div class="post-date">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
              </svg>
              <span>August 24, 2024</span>
            </div>
            <div class="post-reading-time">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
              </svg>
              <span>6 min read</span>
            </div>
          </div>
        </header>
        <div class="post-content">
<p>As a web developer, your choice of tools can dramatically impact your productivity, code quality, and overall enjoyment of the development process. Over the years, I&#39;ve experimented with countless frameworks, libraries, and tools before settling on my current tech stack. In this post, I&#39;ll share the tools I use daily and explain why I&#39;ve chosen each one.</p>
<h2>Frontend Development</h2>
<h3>React: The UI Library That Changed Everything</h3>
<p>React has been my UI library of choice for the past several years, and for good reason:</p>
<ul>
<li><strong>Component-Based Architecture</strong>: Encourages reusable, modular code</li>
<li><strong>Virtual DOM</strong>: Provides excellent performance for UI updates</li>
<li><strong>Massive Ecosystem</strong>: Solutions exist for almost every problem</li>
<li><strong>Strong Community</strong>: Abundant resources, tutorials, and support</li>
<li><strong>Job Market Demand</strong>: Consistently among the most sought-after skills</li>
</ul>
<pre><code class="language-jsx">// A simple React component example
function Welcome({ name }) {
  return (
    &lt;div className=&quot;welcome-card&quot;&gt;
      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
      &lt;p&gt;Welcome to my website.&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>While other frontend frameworks like Vue and Angular have their merits, React&#39;s flexibility and ecosystem make it my preferred choice for most projects.</p>
<h3>TypeScript: Adding Type Safety to JavaScript</h3>
<p>TypeScript has transformed how I write JavaScript code:</p>
<ul>
<li><strong>Static Type Checking</strong>: Catches type-related bugs before runtime</li>
<li><strong>Improved Intellisense</strong>: Better autocomplete and documentation</li>
<li><strong>Enhanced Refactoring</strong>: Makes large-scale changes safer</li>
<li><strong>Interface Definitions</strong>: Clearly communicates expected data structures</li>
</ul>
<pre><code class="language-typescript">// TypeScript example
interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

function formatUserDisplay(user: User): string {
  return `${user.name} (${user.email})`;
}
</code></pre>
<p>TypeScript&#39;s learning curve is well worth the investment. After adopting it, I&#39;ve experienced fewer bugs, more readable code, and smoother collaboration on team projects.</p>
<h3>Zustand: State Management Simplified</h3>
<p>After trying Redux, MobX, and Context API, I&#39;ve settled on Zustand for state management:</p>
<ul>
<li><strong>Minimal API</strong>: Simple and intuitive with almost no boilerplate</li>
<li><strong>No Providers/Consumers</strong>: Direct store access without wrapper components</li>
<li><strong>TypeScript Integration</strong>: Excellent type inference</li>
<li><strong>Performance</strong>: Efficient renders with fine-grained updates</li>
</ul>
<pre><code class="language-javascript">// Zustand store example
import create from &#39;zustand&#39;;

const useStore = create((set) =&gt; ({
  bears: 0,
  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),
  removeAllBears: () =&gt; set({ bears: 0 }),
}));

// Using the store in a component
function BearCounter() {
  const bears = useStore((state) =&gt; state.bears);
  return &lt;h1&gt;{bears} bears around here&lt;/h1&gt;;
}
</code></pre>
<p>For smaller applications, I sometimes use React&#39;s built-in useState and useReducer hooks, but Zustand scales beautifully for more complex state management needs.</p>
<h2>Backend Development</h2>
<h3>Node.js: JavaScript Everywhere</h3>
<p>Using JavaScript on both frontend and backend offers significant advantages:</p>
<ul>
<li><strong>Code Sharing</strong>: Reuse validation logic, types, and utilities</li>
<li><strong>Developer Efficiency</strong>: One language for the entire stack</li>
<li><strong>JSON Handling</strong>: Native format for both environments</li>
<li><strong>NPM Ecosystem</strong>: Access to thousands of packages</li>
</ul>
<pre><code class="language-javascript">// Simple Node.js Express API example
const express = require(&#39;express&#39;);
const app = express();

app.get(&#39;/api/users&#39;, async (req, res) =&gt; {
  try {
    const users = await db.getUsers();
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () =&gt; {
  console.log(&#39;Server running on port 3000&#39;);
});
</code></pre>
<h3>Express: The Flexible Backend Framework</h3>
<p>Express remains my go-to Node.js framework for its:</p>
<ul>
<li><strong>Minimalist Design</strong>: Provides only what you need</li>
<li><strong>Middleware Ecosystem</strong>: Extensive collection of plugins</li>
<li><strong>Routing System</strong>: Simple yet powerful</li>
<li><strong>Performance</strong>: Lightweight with minimal overhead</li>
</ul>
<p>For more structured applications, I sometimes use NestJS, which brings Angular-inspired organization to backend development.</p>
<h2>Database Technologies</h2>
<h3>SQL Server: For Enterprise Applications</h3>
<p>For enterprise-level applications with complex relationships and transaction requirements, I choose SQL Server:</p>
<ul>
<li><strong>ACID Compliance</strong>: Reliable transactions</li>
<li><strong>Advanced Query Capabilities</strong>: Complex joins and stored procedures</li>
<li><strong>Robust Security</strong>: Enterprise-grade protection</li>
<li><strong>Scalability</strong>: Handles large datasets efficiently</li>
</ul>
<pre><code class="language-sql">-- SQL Server example
CREATE TABLE Users (
    UserId INT PRIMARY KEY IDENTITY(1,1),
    Email NVARCHAR(100) NOT NULL UNIQUE,
    PasswordHash NVARCHAR(128) NOT NULL,
    CreatedDate DATETIME2 DEFAULT GETDATE(),
    LastLoginDate DATETIME2 NULL
);
</code></pre>
<h3>SQLite: For Simpler Applications</h3>
<p>For smaller projects, prototypes, and applications that don&#39;t require a separate database server, SQLite is perfect:</p>
<ul>
<li><strong>Zero Configuration</strong>: No server setup required</li>
<li><strong>Self-Contained</strong>: Single file database</li>
<li><strong>Cross-Platform</strong>: Works everywhere</li>
<li><strong>Surprisingly Powerful</strong>: Supports most SQL features</li>
</ul>
<pre><code class="language-javascript">// Using SQLite with Node.js
const sqlite3 = require(&#39;sqlite3&#39;);
const db = new sqlite3.Database(&#39;./database.sqlite&#39;);

db.run(`
  CREATE TABLE IF NOT EXISTS posts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`);
</code></pre>
<h2>Development Environment &amp; Tools</h2>
<h3>VS Code: The Ultimate Editor</h3>
<p>VS Code has become the industry standard for web development, and for good reason:</p>
<ul>
<li><strong>Extensions</strong>: Thousands of plugins for every language and framework</li>
<li><strong>Integrated Terminal</strong>: Run commands without leaving the editor</li>
<li><strong>Git Integration</strong>: Visual diff tools and source control</li>
<li><strong>Debugging Tools</strong>: Breakpoints, watch variables, and more</li>
<li><strong>Performance</strong>: Remarkably fast for an Electron app</li>
</ul>
<p>Essential extensions I use daily:</p>
<ul>
<li>ESLint</li>
<li>Prettier</li>
<li>GitLens</li>
<li>ES7+ React/Redux/React-Native snippets</li>
<li>Thunder Client (API testing)</li>
</ul>
<h3>Docker: Consistent Development Environments</h3>
<p>Docker ensures consistent environments across development, testing, and production:</p>
<ul>
<li><strong>Environment Isolation</strong>: Prevents &quot;works on my machine&quot; problems</li>
<li><strong>Microservices</strong>: Easily decompose applications</li>
<li><strong>Dependency Management</strong>: Package everything together</li>
<li><strong>CI/CD Integration</strong>: Streamlines deployment pipelines</li>
</ul>
<pre><code class="language-dockerfile"># Example Dockerfile for a Node.js application
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000
CMD [&quot;npm&quot;, &quot;start&quot;]
</code></pre>
<h2>Why This Stack Works For Me</h2>
<p>This technology stack has evolved through years of professional experience, and it works exceptionally well for several reasons:</p>
<ol>
<li><p><strong>TypeScript + React + Node.js</strong>: Using TypeScript throughout the stack creates a seamless development experience with shared types and validation logic.</p>
</li>
<li><p><strong>Balanced Learning Curve</strong>: While some tools have steeper learning curves (TypeScript), others are more approachable (Zustand), creating a balanced stack for teams with mixed experience levels.</p>
</li>
<li><p><strong>Performance Focused</strong>: Each tool is chosen with performance in mind, from React&#39;s virtual DOM to SQLite&#39;s lightweight footprint.</p>
</li>
<li><p><strong>Scalability</strong>: This stack scales from small personal projects to large enterprise applications.</p>
</li>
</ol>
<h2>Trade-offs and Alternatives</h2>
<p>No stack is perfect for every situation. Here are some trade-offs and alternatives I consider:</p>
<table>
<thead>
<tr>
<th>Tool I Use</th>
<th>Alternatives</th>
<th>When I Might Switch</th>
</tr>
</thead>
<tbody><tr>
<td>React</td>
<td>Vue, Svelte</td>
<td>For smaller projects needing less boilerplate</td>
</tr>
<tr>
<td>TypeScript</td>
<td>Plain JavaScript</td>
<td>For quick prototypes or tiny scripts</td>
</tr>
<tr>
<td>Node.js/Express</td>
<td>Django, Rails, .NET</td>
<td>For teams with existing expertise</td>
</tr>
<tr>
<td>SQL Server/SQLite</td>
<td>MongoDB, PostgreSQL</td>
<td>For document-oriented data or advanced PostgreSQL features</td>
</tr>
</tbody></table>
<h2>Conclusion</h2>
<p>The tools we choose as developers shape our daily experience and the quality of our work. My current stack of React, TypeScript, Zustand, Node.js, Express, and SQL/SQLite provides a productive, maintainable, and enjoyable development experience.</p>
<p>Remember that the best stack is the one that works for your specific needs, team, and project requirements. Don&#39;t be afraid to experiment with new tools, but also recognize the value in mastering a core set of technologies.</p>
<hr>
<p><em>What&#39;s your preferred web development stack? I&#39;d love to hear about your experiences with different tools in the comments below!</em></p>
</div>
        <a href="/portfolio-blog/" class="back-link">← Back to Home</a>
      </article>
    
    </main>
    
    <footer>
      <p>&copy; 2025 Portfolio Blog</p>
    </footer>
  </div>
  <script>
    // Simple navigation without page reloads
    document.addEventListener('click', function(e) {
      if (e.target.tagName === 'A' && !e.target.getAttribute('target')) {
        const href = e.target.getAttribute('href');
        if (href.startsWith('/') && !href.startsWith('//')) {
          e.preventDefault();
          window.location.href = href;
        }
      }
    });
  </script>
</body>
</html>